# beans — Hierarchical Task Engine
# A Rust CLI for goal-driven, agent-executable task management
# Individual YAML files, sequential IDs, auto-indexed

project: beans
binary: bn
version: "0.1.0"
repo: standalone # not in swarm-toolkit workspace
language: rust

# ─────────────────────────────────────────────
# Philosophy
# ─────────────────────────────────────────────
#
# Beans is a task tracker where each task is a file you can read,
# edit, grep, and git-diff. No databases. No daemons.
#
# A bean is a unit of work with enough context to execute autonomously.
# Parent beans provide strategic context. Leaf beans are self-contained
# agent prompts — swarmable.
#
# Hierarchy is structural: has children = container, no children = leaf.
# No fixed types. Any bean can be decomposed further or executed directly.
#
# The planning workflow:
#   1. Create a goal bean (bn create "Build beans")
#   2. Discuss and refine with an agent or human
#   3. Decompose into sub-beans (bn create --parent 1 "Design schema")
#   4. Keep splitting until beans are agent-executable
#   5. Swarm the leaf beans
#
# Sequential numbering with dot-notation makes hierarchy visible
# in the filesystem — no need to open files to see structure.

# ─────────────────────────────────────────────
# File Layout
# ─────────────────────────────────────────────

layout:
  root: ".beans/"
  goal: ".beans/bean.yaml"           # root goal / spec — never swarmed, always decomposed
  tasks: ".beans/{number}.yaml"      # e.g., .beans/1.yaml, .beans/3.2.yaml
  index: ".beans/index.yaml"         # auto-rebuilt cache
  config: ".beans/config.yaml"       # project settings

  # bean.yaml is the root — the spec, the strategic context, the goal.
  # It's what the orchestrating agent reads to understand the project.
  # It is not numbered because it is not swarmable.
  # Everything numbered is a product of decomposition and potentially swarmable.

  # Examples:
  #   .beans/
  #     config.yaml
  #     index.yaml
  #     bean.yaml             # root goal / spec (the "what and why")
  #     1.yaml                # "Project scaffolding" (decomposed from bean.yaml)
  #     2.yaml                # "YAML data model"
  #     3.yaml                # "Implement CLI"
  #     3.1.yaml              # "bn create command" (child of 3)
  #     3.2.yaml              # "bn list/show commands" (child of 3)
  #     3.3.yaml              # "bn dep command" (child of 3)
  #     4.yaml                # "Implement auto-index"

# ─────────────────────────────────────────────
# Data Model — Bean
# ─────────────────────────────────────────────

bean:
  # --- Required fields ---
  id:
    type: integer (dot-notation for children)
    format: "{number}"  # bare numbers: 1, 3, 3.2, 3.2.1
    description: >
      Sequential integer at top level. Dot-notation for children.
      The numeric part is auto-incremented from config.yaml next_id.
      Children append .N to their parent's number.
      CLI commands accept bare numbers: bn show 3.2
      No project prefix in the ID — the project context is implicit
      from which .beans/ directory you're in.
    examples: [1, 3, 3.2, 3.2.1]

  title:
    type: string
    required: true
    description: Short human-readable summary

  status:
    type: enum
    values: [open, in_progress, closed]
    default: open
    description: >
      Three states only. "blocked" is derived from dependencies,
      never stored. A bean with unresolved dependencies is blocked
      regardless of its status field.

  priority:
    type: integer
    range: [0, 4]  # 0 = critical, 4 = backlog
    default: 2
    description: P0-P4 numeric priority, 0 is highest

  created_at:
    type: datetime  # ISO 8601
    auto: true

  updated_at:
    type: datetime
    auto: true

  attempts:
    type: integer
    default: 0
    description: >
      Number of times `bn close` has been attempted on this bean.
      Incremented on each close attempt (successful or failed).
      Used to track retries and trigger max_attempts circuit breaker.

  max_attempts:
    type: integer
    description: >
      Maximum number of close attempts allowed. If attempts reaches
      this value, `bn close` fails with "max attempts exceeded."
      Prevents infinite retry loops. Typical value: 3-5. If not set,
      no limit (but swarm orchestration should set a sane default).

  # --- Optional fields ---
  description:
    type: string
    description: >
      The primary context field. For leaf beans, this is effectively
      the agent prompt — rich enough that an agent can pick it up
      cold and execute. Include file paths, code snippets, design
      decisions, and acceptance criteria here.

  acceptance:
    type: string
    description: >
      What "done" looks like. Testable criteria. Agents check these
      before closing. Can also be embedded in description but this
      field makes it greppable.

  verify:
    type: string
    description: >
      Shell command that must exit 0 for `bn close` to succeed.
      This is the machine-checkable gate — acceptance criteria are
      prose for the agent, verify is the automated proof.
      `bn close <id>` runs this command and only closes the bean
      if it passes. There is no force flag. If verify fails, the
      bean stays open. `bn verify <id>` runs the check without
      closing, useful for agents to check progress mid-work.
    examples:
      - "cargo test --lib commands::list commands::show"
      - "python -m pytest tests/test_auth.py"
      - "npm test -- --grep 'token validation'"

  notes:
    type: string
    description: >
      Handoff notes from the agent that completed this bean.
      What was created, where, and what downstream beans need to know.
      Written by the worker before closing.

  design:
    type: string
    description: >
      Design decisions and rationale. Why this approach was chosen.
      Useful for parent/goal beans where the "why" matters as much
      as the "what".

  labels:
    type: array
    items: string
    description: Freeform tags for filtering
    examples: [["rust", "cli"], ["blocked-on-external", "p0"]]

  assignee:
    type: string
    description: Who is working on this (human name or agent ID)

  closed_at:
    type: datetime
    description: When the bean was closed

  close_reason:
    type: string
    description: Why it was closed (human-written summary)

  # --- Structural fields ---
  parent:
    type: string
    description: >
      Parent bean ID. Defines hierarchy. A bean with children is
      a container; a bean without children is a leaf (swarmable).
      Stored in the YAML but also encoded in the filename:
      3.1.yaml is a child of 3.yaml.

  dependencies:
    type: array
    items: string  # bean IDs
    description: >
      Beans that must be closed before this bean can start.
      This is the DAG edge list. "blocked" status is derived:
      if any dependency is not closed, this bean is blocked.
    examples: [[2, 4]]

# ─────────────────────────────────────────────
# Index — Auto-rebuilt Cache
# ─────────────────────────────────────────────

index:
  description: >
    Lightweight cache rebuilt automatically when any .yaml file
    has a newer mtime than index.yaml. Every read command
    (bn ready, bn list, bn blocked) checks and rebuilds if stale.
    Write commands (bn create, bn update, bn close) update both
    the task YAML and the index in one operation.

    The index exists so that read-heavy operations (ready, list,
    blocked, tree) don't need to glob and parse every YAML file.
    For <500 beans this is a negligible optimization, but it costs
    nothing to maintain and prevents any future scaling concern.

  file: index.yaml
  schema:
    beans:
      type: array
      items:
        id: string
        title: string
        status: string
        priority: integer
        parent: string | null
        dependencies: array of string
        labels: array of string
        updated_at: datetime

  rebuild_trigger: >
    Any YAML file mtime > index.yaml mtime.
    Also: `bn sync` forces rebuild unconditionally.

# ─────────────────────────────────────────────
# CLI Commands
# ─────────────────────────────────────────────

commands:

  # --- Core CRUD ---

  create:
    usage: "bn create [title] [flags]"
    aliases: ["new"]
    description: Create a new bean
    flags:
      --title: "Bean title (alternative to positional arg)"
      --description: "Full description / agent context"
      --acceptance: "Acceptance criteria"
      --notes: "Additional notes"
      --design: "Design decisions"
      --verify: "Shell command that must exit 0 to close"
      --parent: "Parent bean ID — child gets next dot-number"
      --priority: "P0-P4 (default: P2)"
      --labels: "Comma-separated labels"
      --assignee: "Assignee name"
      --deps: "Comma-separated dependency IDs"
    behavior: >
      Creates {id}.yaml in .beans/, updates index.yaml.
      If --parent is given, ID is auto-assigned as parent.N
      (next available child number).
      If no --parent, ID is next top-level integer.
    examples:
      - "bn create 'Build beans'"
      - "bn create --parent 3 'Implement bn create command'"
      - "bn create --parent 3 --deps 2 'Needs schema first'"

  show:
    usage: "bn show <id>"
    aliases: ["view"]
    description: Display full bean details
    flags:
      --json: "Output as JSON"
      --short: "One-line summary"
    behavior: >
      Reads {id}.yaml directly. Also shows derived info:
      children (from index), blocked status (from dependency resolution),
      dependents (reverse lookup from index).

  list:
    usage: "bn list [flags]"
    aliases: ["ls"]
    description: List beans with filtering
    flags:
      --status: "Filter by status (open, in_progress, closed)"
      --priority: "Filter by priority"
      --parent: "Show children of a parent"
      --label: "Filter by label"
      --assignee: "Filter by assignee"
      --all: "Include closed beans"
      --tree: "Hierarchical tree display"
      --json: "JSON output"
      --limit: "Max results (default: 50)"
    behavior: Reads from index.yaml (rebuilds if stale).

  update:
    usage: "bn update <id> [flags]"
    description: Update bean fields
    flags:
      --title: "New title"
      --description: "New description"
      --acceptance: "New acceptance criteria"
      --notes: "New/appended notes"
      --design: "New design notes"
      --status: "New status (open, in_progress, closed)"
      --priority: "New priority"
      --assignee: "New assignee"
      --verify: "New verify command"
      --add-label: "Add a label"
      --remove-label: "Remove a label"
    behavior: >
      Reads {id}.yaml, merges changes, writes back, updates index.
      For --notes, appends rather than replaces (with timestamp).

  close:
    usage: "bn close <id> [ids...]"
    description: Close one or more beans (agent-mode, verifies and undoes on failure)
    flags:
      --reason: "Close reason"
    behavior: >
      Beans is designed for agents. bn close always verifies.

      For each bean: increment attempts counter. If bean has a verify
      field, run the command. If verify exits 0: set status=closed,
      closed_at=now. Notes and design survive. Done.

      If verify exits non-zero (or attempts >= max_attempts):
      Call undo via /ai-tools to roll back all changes since the bean
      was assigned. Notes and design survive but all code changes are
      reverted. Bean stays open, stays in ready queue for next agent.
      Attempts counter persists — next agent sees how many tries failed.

      If no verify field exists, just closes (no undo).

      If attempts >= max_attempts: fail with "max attempts exceeded,
      needs human review." Bean does not close or undo.

      Supports closing multiple beans in one command (each is
      processed independently).

  verify:
    usage: "bn verify <id>"
    description: Run a bean's verify command without closing
    behavior: >
      Reads the verify field from {id}.yaml and runs it as a shell
      command. Prints the output and exits with the same code.
      Useful for agents to check progress mid-work without
      attempting to close. If no verify field exists, exits 0.

  reopen:
    usage: "bn reopen <id>"
    description: Reopen a closed bean
    behavior: Sets status=open, clears closed_at and close_reason.

  delete:
    usage: "bn delete <id>"
    description: Delete a bean and clean up references
    behavior: >
      Removes {id}.yaml. Removes this ID from all other beans'
      dependency lists. Rebuilds index.

  # --- Dependencies ---

  dep:
    usage: "bn dep <subcommand>"
    description: Manage dependencies between beans
    subcommands:
      add:
        usage: "bn dep add <id> <depends-on-id>"
        description: "Add dependency (id depends on depends-on-id)"
      remove:
        usage: "bn dep remove <id> <depends-on-id>"
        description: Remove a dependency
      list:
        usage: "bn dep list <id>"
        description: Show dependencies and dependents of a bean
      tree:
        usage: "bn dep tree [id]"
        description: Show full dependency tree (or project-wide DAG)
      cycles:
        usage: "bn dep cycles"
        description: Detect dependency cycles in the graph

  # --- Views ---

  ready:
    usage: "bn ready"
    description: >
      Show beans ready to work on. A bean is ready when:
      status=open AND no unresolved dependencies (all deps closed).
      Sorted by priority.

  blocked:
    usage: "bn blocked"
    description: Show beans blocked by unresolved dependencies

  tree:
    usage: "bn tree [id]"
    description: >
      Show hierarchical tree of beans.
      If id given, show subtree rooted at that bean.
      If no id, show full project tree.
    behavior: >
      Reads index. Displays parent/child relationships with
      status indicators. Example output:
        [x] 1. Build beans (closed)
        [ ] 2. Design YAML schema (open)
        [-] 3. Implement CLI (in_progress)
          [x] 3.1 bn create command (closed)
          [-] 3.2 bn list/show commands (in_progress)
          [ ] 3.3 bn dep command (open)

  graph:
    usage: "bn graph [flags]"
    description: Display dependency graph
    flags:
      --format: "Output format: mermaid (default), dot"
    behavior: >
      Reads index, emits Mermaid or Graphviz DOT syntax
      showing dependency edges. Pipe to renderer:
      bn graph | mmdc -o graph.png

  # --- Index Management ---

  sync:
    usage: "bn sync"
    description: >
      Force rebuild index from YAML files.
      Normally automatic — this is the manual override.
      Like `git gc`: exists but you rarely type it.

  # --- Project Setup ---

  init:
    usage: "bn init [project-name]"
    description: >
      Initialize beans in current directory.
      Creates .beans/ directory and config.yaml.
      Auto-detects project name from directory if not given.

  # --- Info ---

  stats:
    usage: "bn stats"
    description: >
      Project statistics: open/closed/blocked counts,
      beans by priority, top-level goal progress.

  doctor:
    usage: "bn doctor"
    description: >
      Health check: orphaned dependencies, missing parent refs,
      cycle detection, index freshness.

# ─────────────────────────────────────────────
# Config
# ─────────────────────────────────────────────

config:
  file: ".beans/config.yaml"
  fields:
    project:
      type: string
      description: >
        Project name. Used in bn stats and bean.yaml context.
        Auto-detected from directory name at init.
      example: "beans"
    next_id:
      type: integer
      description: >
        Next top-level ID to assign. Auto-incremented.
        Child IDs are managed per-parent (next child number
        derived by scanning existing {parent}.N.yaml files).
      default: 1

# ─────────────────────────────────────────────
# Example Bean File
# ─────────────────────────────────────────────

example:
  file: ".beans/3.2.yaml"
  content: |
    id: 3.2
    title: Implement bn list and bn show commands
    status: open
    priority: 2
    parent: 3
    dependencies:
      - 2    # schema must be designed first
    labels:
      - cli
      - core
    assignee: null
    created_at: 2026-01-26T15:00:00-08:00
    updated_at: 2026-01-26T15:00:00-08:00
    description: |
      Implement the `bn list` and `bn show` commands for the beans CLI.

      ## bn show <id>
      - Read .beans/{id}.yaml and display all fields
      - Show raw YAML (cat the file)
      - Support --json flag for machine-readable output

      ## bn list [flags]
      - Read from index.yaml (rebuild if stale)
      - Filter by: --status, --priority, --parent, --label, --assignee
      - Default: tree-format output with numbers and titles
      - --all flag: include closed beans

      ## Files
      - src/commands/show.rs
      - src/commands/list.rs
      - src/index.rs (read_index, is_stale)

    acceptance: |
      - `bn show 1` cats the YAML for bean 1
      - `bn show 1 --json` outputs valid JSON
      - `bn list` shows tree-format with status indicators
      - `bn list --parent 3` shows only children of bean 3
      - `bn list --status closed` shows closed beans
      - Index auto-rebuilds when stale

# ─────────────────────────────────────────────
# Implementation Beads (for decomposition)
# ─────────────────────────────────────────────
#
# This spec is designed to decompose into beans once bn init works.
# Suggested decomposition:
#
# bean-1: "Build beans" (goal)
#   bean-2: "Project scaffolding" (Cargo.toml, src/main.rs, clap setup)
#   bean-3: "YAML data model" (Bean struct, serde, read/write)
#   bean-4: "Index engine" (build, staleness check, auto-rebuild)
#   bean-5: "Core commands" (parent: 1)
#     bean-5.1: "bn init" (create .beans/, config.yaml)
#     bean-5.2: "bn create" (deps: 3, 4)
#     bean-5.3: "bn show" (deps: 3, 4)
#     bean-5.4: "bn list" (deps: 4)
#     bean-5.5: "bn update" (deps: 3)
#     bean-5.6: "bn close / bn reopen" (deps: 3)
#     bean-5.7: "bn delete" (deps: 3, 4)
#   bean-6: "Dependency commands" (parent: 1, deps: 3)
#     bean-6.1: "bn dep add/remove"
#     bean-6.2: "bn dep list/tree"
#     bean-6.3: "bn dep cycles"
#     bean-6.4: "bn ready / bn blocked" (deps: 4)
#   bean-7: "View commands" (parent: 1, deps: 4)
#     bean-7.1: "bn tree"
#     bean-7.2: "bn graph"
#     bean-7.3: "bn stats"
#     bean-7.4: "bn doctor"
#   bean-8: "bn sync — force index rebuild"
#
# Total: ~20 beans across 4 waves
# Wave 1: 2, 3 (parallel — scaffolding + data model)
# Wave 2: 4, 5.1 (index engine + init)
# Wave 3: 5.2-5.7, 6.1-6.3 (core + dep commands)
# Wave 4: 6.4, 7.1-7.4, 8 (views + sync)

# ─────────────────────────────────────────────
# Directory Discovery
# ─────────────────────────────────────────────

discovery:
  description: >
    bn walks up parent directories from cwd to find .beans/,
    like git finds .git/. First .beans/ directory found is used.
    bn init creates .beans/ in the current directory.

# ─────────────────────────────────────────────
# Output Formats
# ─────────────────────────────────────────────

output:

  show:
    description: >
      Cats the raw YAML file. What you see is what's stored.
      No formatting, no derived fields — just the file.
      Optionally --json for machine consumption.

  list:
    description: >
      Tree-format output showing bean numbers and titles
      with status indicators.
    example: |
      [ ] 1. Project scaffolding
      [ ] 2. YAML data model
      [-] 3. Implement CLI
        [x] 3.1 bn create command
        [-] 3.2 bn list/show commands
        [ ] 3.3 bn dep command
      [ ] 4. Implement auto-index

      Legend: [ ] open  [-] in_progress  [x] closed  [!] blocked

  ready:
    description: >
      Flat list of beans with no unresolved dependencies
      and status=open, sorted by priority.
    example: |
      P0  1    Project scaffolding
      P0  2    YAML data model
      P2  3.3  bn dep command

  blocked:
    description: >
      Flat list of blocked beans with what's blocking them.
    example: |
      3.2  bn list/show commands  ← blocked by: 2

# ─────────────────────────────────────────────
# Error Handling
# ─────────────────────────────────────────────

errors:
  no_beans_dir: >
    "No .beans/ directory found. Run `bn init` first."
    Printed when discovery walks to filesystem root without finding .beans/.

  bean_not_found: >
    "Bean {id} not found."
    Printed when {id}.yaml doesn't exist.

  duplicate_id: >
    Should not happen with auto-increment. If a user manually
    creates a conflicting file, bn detects it on index rebuild
    and warns: "Duplicate bean ID {id} — resolve manually."

  cycle_detected: >
    "Dependency cycle detected: {id1} → {id2} → ... → {id1}"
    bn dep add refuses to create edges that would form cycles.
    bn dep cycles scans for and reports all cycles.

  invalid_yaml: >
    "Failed to parse {file}: {error}"
    Printed when a YAML file is malformed. Bean is skipped
    in index rebuild, other beans are unaffected.

# ─────────────────────────────────────────────
# Blocked Derivation
# ─────────────────────────────────────────────

blocked_derivation:
  description: >
    A bean is blocked if ANY of its immediate dependencies
    has status != closed. Not transitive — if A depends on B
    and B depends on C, A only checks B's status, not C's.
    If B is open because C is blocking it, B is not closed,
    so A is blocked. Transitivity emerges naturally without
    needing to walk the full graph.

    bn ready returns: status=open AND not blocked.
    bn blocked returns: status=open AND blocked.
    Beans with status=in_progress or status=closed are
    excluded from both views.

# ─────────────────────────────────────────────
# bean.yaml Detection
# ─────────────────────────────────────────────

bean_yaml:
  description: >
    bean.yaml is the root goal / spec. bn does not parse it
    as a task — it's for human and orchestrator consumption only.
    bn treats it as documentation, not a trackable work item.

    If bean.yaml's mtime is newer than any numbered bean's mtime,
    bn list prints a notice:
    "bean.yaml modified since last decomposition — consider re-running /decompose"

    This is a hint, not an error. No automatic propagation.

# ─────────────────────────────────────────────
# Design Decisions
# ─────────────────────────────────────────────

decisions:
  - name: "YAML over SQLite"
    rationale: >
      Human readability is the primary concern. Each bean is a file
      you can open in your editor, browse in a file tree, grep across,
      and git-diff. SQLite optimizes for machine access; beans optimizes
      for human access.

  - name: "Sequential IDs with dot-notation"
    rationale: >
      Hierarchy visible in filenames. ls .beans/ shows structure.
      3.2.yaml is obviously a child of 3.yaml. Random IDs (beads)
      require opening the file or querying to understand relationships.

  - name: "Auto-indexed, not database-backed"
    rationale: >
      Index is a cache, not a source of truth. YAML files are truth.
      Index rebuilds are cheap (<1ms for hundreds of beans). This
      eliminates an entire class of sync/consistency bugs.

  - name: "No fixed types (goal/subgoal/task)"
    rationale: >
      Hierarchy is structural. Has children = container.
      No children = leaf = swarmable. Types add ceremony without
      value — a "task" that gets decomposed becomes a "subgoal"
      implicitly by having children.

  - name: "Context-as-description"
    rationale: >
      A bean's description is its agent prompt. Rich enough for
      cold execution. This is the single most important field —
      file paths, code snippets, design decisions, acceptance
      criteria all live here. Notes field is for post-execution
      handoff context written by the completing agent.

  - name: "No daemon, no background processes"
    rationale: >
      Stateless CLI. Read files, write files, exit.
      Index staleness is checked on read via mtime comparison.
      No lock files, no PID files, no socket files.

  - name: "Git is the sync layer"
    rationale: >
      git add .beans/ && git commit is the sync.
      No JSONL export, no special merge drivers, no sync branches.
      YAML files diff cleanly. Git handles versioning, branching,
      and collaboration natively.

# ─────────────────────────────────────────────
# Decomposition Workflow — /decompose skill
# ─────────────────────────────────────────────
#
# The core workflow that drives beans. Not a CLI command —
# a Claude skill that orchestrates the conversation between
# human intent and agent-executable work.
#
# /create (beads) creates pre-planned work items.
# /decompose (beans) IS the planning — an interactive
# conversation that progressively refines a goal into
# swarmable leaf beans.

decompose_skill:
  name: "/decompose"
  trigger: "decompose, split beans, break down, plan beans"
  description: >
    Interactive skill for progressive decomposition of beans.
    Takes a bean (usually a goal or large subgoal) and
    collaborates with the human to split it into smaller beans
    until every leaf is agent-executable.

  workflow:
    step_1_understand:
      name: "Read the bean"
      action: >
        bn show <id> — read the bean's full context.
        If it's a goal bean, understand the strategic intent.
        If it's a subgoal, understand what part of the parent
        it addresses.

    step_2_explore:
      name: "Gather codebase context"
      action: >
        Use scan/grep/read to understand the codebase areas
        this bean touches. Identify:
        - Files that will be modified
        - Existing patterns to follow
        - Types, interfaces, APIs involved
        - Test patterns

    step_3_propose:
      name: "Propose decomposition"
      action: >
        Present the human with a proposed split. For each
        proposed child bean, show:
        - Title
        - Files it touches (1-5)
        - What it produces (artifacts)
        - What it requires (dependencies)
        - Why it's this size (not bigger, not smaller)

    step_4_discuss:
      name: "Refine with human"
      action: >
        The human may:
        - Agree with the split
        - Merge beans they think are too small
        - Split beans they think are too big
        - Reorder priorities
        - Add constraints or context
        This is a conversation, not a one-shot.

    step_5_readiness_check:
      name: "Check if leaves are swarmable"
      action: >
        For each leaf bean, apply the readiness test.
        If any leaf fails, recurse — decompose it further.
        If all pass, the decomposition is complete.

    step_6_create:
      name: "Create the beans"
      action: >
        bn create --parent <id> for each child.
        bn dep add for dependency edges.
        bn dep cycles to validate.
        bn tree <root> to show the final structure.

  readiness_test:
    description: >
      A leaf bean is "swarmable" (ready for autonomous agent
      execution) when ALL of the following are true:

    criteria:
      - name: "Self-contained context"
        test: >
          The description contains enough information for an
          agent to start working without asking questions.
          File paths, relevant code snippets, patterns to follow,
          and things to avoid are all included.

      - name: "Bounded scope"
        test: >
          A single concern — not "implement X and also Y."
          Size by function count:
          - Functions to write: 1-5
          - Functions to read for context: 2-10
          If more, split further.

      - name: "Testable acceptance"
        test: >
          The acceptance field has specific, verifiable criteria.
          An agent can check these before closing.
          Not vague ("works correctly") but concrete
          ("bn list --tree shows hierarchical output").

      - name: "No ambiguity"
        test: >
          There are no design decisions left to make.
          The "how" is clear, not just the "what."
          If an agent would need to choose between approaches,
          the bean should specify which approach.

      - name: "Fits in context"
        test: >
          Estimated token usage <64k. Heuristic:
          - 1-2 fns to write, 2-5 to read: ~20-35k tokens
          - 3-4 fns to write, 5-8 to read: ~35-50k tokens
          - 5 fns to write, 8-10 to read: ~50-65k tokens
          - >5 fns to write or >10 to read: TOO BIG, split

    failure_modes:
      too_big: >
        Bean touches too many files or has too many acceptance
        criteria. Split by file group or responsibility.
      too_vague: >
        Description says "implement feature" without specifying
        how. Add file paths, patterns, code snippets.
      ambiguous: >
        Multiple valid approaches exist and the bean doesn't
        specify which one. Make the design decision, record it
        in the design field, then the bean is ready.
      missing_context: >
        Agent would need to explore the codebase to understand
        what to do. Embed the relevant code in the description
        so the agent starts informed.

  example_session: |
    User: /decompose beans-3

    Agent: Reading bean 3: "Implement CLI"

    This bean covers all CLI commands for beans. That's ~15
    commands across create, show, list, update, close, dep,
    ready, blocked, tree, graph, sync, init, stats, doctor.

    Way too big for one agent. I'd split by command group:

    1. beans-3.1: "bn init" — project setup (1 file)
    2. beans-3.2: "bn create" — creates beans (2 files)
    3. beans-3.3: "bn show + bn list" — read commands (3 files)
    4. beans-3.4: "bn update + bn close + bn reopen" — write commands (2 files)
    5. beans-3.5: "bn delete" — cleanup with reference removal (2 files)
    6. beans-3.6: "bn dep add/remove/list/tree/cycles" — dependency management (3 files)
    7. beans-3.7: "bn ready + bn blocked" — derived views (2 files)
    8. beans-3.8: "bn tree + bn graph" — visualization (2 files)
    9. beans-3.9: "bn stats + bn doctor + bn sync" — housekeeping (2 files)

    Dependencies:
    - 3.2 depends on 3.1 (init creates config that create reads)
    - 3.3 depends on 3.2 (need beans to show/list)
    - 3.4 depends on 3.2 (need beans to update/close)
    - 3.5 depends on 3.2 (need beans to delete)
    - 3.6 depends on 3.2 (need beans for dep edges)
    - 3.7 depends on 3.6 (ready/blocked reads dep graph)
    - 3.8 depends on 3.6 (tree/graph reads dep graph)
    - 3.9 depends on 3.3 (stats reads the index)

    Some of these could parallelize. What do you think?
    Should I merge any of these? Split any further?

    User: 3.3 looks fine. merge 3.4 and 3.5 — delete is
    basically close + remove file. and merge 3.8 and 3.9.

    Agent: Good calls. Revised:

    1. beans-3.1: "bn init" (1 file)
    2. beans-3.2: "bn create" (2 files)
    3. beans-3.3: "bn show + bn list" (3 files)
    4. beans-3.4: "bn update + bn close + bn reopen + bn delete" (3 files)
    5. beans-3.5: "bn dep add/remove/list/tree/cycles" (3 files)
    6. beans-3.6: "bn ready + bn blocked" (2 files)
    7. beans-3.7: "bn tree + bn graph + bn stats + bn doctor + bn sync" (3 files)

    Readiness check:
    - 3.1 through 3.6: all pass (bounded scope, clear files, testable)
    - 3.7: borderline — 5 commands in one bean, but they're all
      read-only views over the index. Should be fine at ~55k tokens.

    Create these? [y/N]

id: '13.3'
title: Add bn resolve command for manual conflict resolution
slug: add-bn-resolve-command-for-manual-conflict-resolut
status: closed
priority: 2
created_at: 2026-02-03T07:22:36.213008Z
updated_at: 2026-02-03T07:29:38.980023Z
description: "## What to implement\n\nCreate the `bn resolve` command for manually resolving bean conflicts:\n\n1. **Create src/commands/resolve.rs** - New command module\n2. **cmd_resolve()** - Main command handler\n3. **Bean::apply_value()** - Helper to set a field value by name\n4. **CLI integration** - Wire up subcommand in main.rs\n\n## Files\n- src/commands/resolve.rs (create - new command)\n- src/commands/mod.rs (modify - add `pub mod resolve;` and re-export)\n- src/main.rs (modify - add resolve subcommand)\n\n## Context\n\n### Command signature\n```bash\nbn resolve <bean-id> <field> <choice>\n# choice: 0, 1, 2... (which version to keep)\n\n# Example:\nbn resolve 5 status 0  # Keep first version\n```\n\n### Implementation pattern from design doc\n```rust\n// src/commands/resolve.rs\nuse crate::bean::{Bean, ConflictResolution};\nuse crate::index::Index;\nuse crate::util::find_bean_file;\nuse anyhow::{anyhow, Result};\nuse std::path::Path;\n\npub fn cmd_resolve(\n    beans_dir: &Path,\n    id: &str,\n    field: &str,\n    choice: usize,\n) -> Result<()> {\n    let bean_path = find_bean_file(beans_dir, id)?;\n    let mut bean = Bean::from_file(&bean_path)?;\n\n    // Find conflict for this field\n    let conflict = bean.conflicts.iter_mut()\n        .find(|c| c.field == field)\n        .ok_or_else(|| anyhow!(\"No conflict for field: {}\", field))?;\n\n    if choice >= conflict.versions.len() {\n        return Err(anyhow!(\"Invalid choice: {}. Available: 0-{}\", \n            choice, conflict.versions.len() - 1));\n    }\n\n    // Get chosen value\n    let chosen_value = &conflict.versions[choice].value;\n\n    // Apply to bean\n    bean.apply_value(field, chosen_value)?;\n\n    // Mark resolved\n    conflict.resolution = ConflictResolution::Resolved;\n\n    // Remove resolved conflicts\n    bean.conflicts.retain(|c| c.resolution == ConflictResolution::Pending);\n\n    // Save\n    bean.to_file(&bean_path)?;\n\n    // Rebuild index\n    let index = Index::build(beans_dir)?;\n    index.save(beans_dir)?;\n\n    println!(\"âœ“ Resolved conflict for bean {} field '{}'\", id, field);\n    Ok(())\n}\n```\n\n### Bean::apply_value helper\n```rust\nimpl Bean {\n    /// Apply a JSON-serialized value to a field by name\n    pub fn apply_value(&mut self, field: &str, json_value: &str) -> Result<()> {\n        match field {\n            \"title\" => self.title = serde_json::from_str(json_value)?,\n            \"status\" => self.status = serde_json::from_str(json_value)?,\n            \"priority\" => self.priority = serde_json::from_str(json_value)?,\n            \"description\" => self.description = serde_json::from_str(json_value)?,\n            \"assignee\" => self.assignee = serde_json::from_str(json_value)?,\n            \"labels\" => self.labels = serde_json::from_str(json_value)?,\n            \"dependencies\" => self.dependencies = serde_json::from_str(json_value)?,\n            // ... other fields\n            _ => return Err(anyhow!(\"Unknown field: {}\", field)),\n        }\n        self.updated_at = chrono::Utc::now();\n        Ok(())\n    }\n}\n```\n\n### CLI integration (main.rs)\n```rust\n// Add to Subcommand enum:\nResolve {\n    /// Bean ID\n    id: String,\n    /// Field name with conflict\n    field: String,\n    /// Version choice (0, 1, ...)\n    choice: usize,\n},\n\n// Add to match:\nSubcommand::Resolve { id, field, choice } => {\n    commands::cmd_resolve(&beans_dir, &id, &field, choice)?;\n}\n```\n\n## Acceptance\n- [ ] `bn resolve <id> <field> <choice>` command works\n- [ ] Correctly applies chosen value to the field\n- [ ] Marks conflict as resolved\n- [ ] Removes conflict from bean when resolved\n- [ ] Updates bean's updated_at timestamp\n- [ ] Rebuilds index after resolution\n- [ ] Error handling for: invalid bean ID, no conflict on field, invalid choice\n- [ ] cargo test commands::resolve passes\n- [ ] cargo build succeeds\n\n## Produces\n- cmd_resolve\n- Bean::apply_value\n\n\n## Requires\n- FieldConflict\n- ConflictResolution\n"
closed_at: 2026-02-03T07:29:38.980023Z
close_reason: |-
  Implemented bn resolve command with:
  - src/commands/resolve.rs: cmd_resolve() function with full test coverage (13 tests)
  - Bean::apply_value() method to set fields by name from JSON values
  - CLI integration in cli.rs and main.rs
  - Module exports in mod.rs

  All acceptance criteria met:
  - `bn resolve <id> <field> <choice>` command works
  - Correctly applies chosen value to the field
  - Marks conflict as resolved and removes from bean
  - Updates bean's updated_at timestamp
  - Rebuilds index after resolution
  - Proper error handling for invalid bean ID, no conflict, invalid choice
  - All tests pass (cargo test commands::resolve)
  - Build succeeds (cargo build)
parent: '13'
verify: cargo test commands::resolve && cargo build
claimed_at: 2026-02-03T07:27:26.288221Z
is_archived: true

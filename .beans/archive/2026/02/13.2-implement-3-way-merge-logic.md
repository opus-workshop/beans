id: '13.2'
title: Implement 3-way merge logic
slug: implement-3-way-merge-logic
status: closed
priority: 2
created_at: 2026-02-03T07:22:18.310822Z
updated_at: 2026-02-03T07:27:31.995536Z
description: "## What to implement\n\nCreate the core merge logic for resolving non-overlapping field changes:\n\n1. **Create src/merge.rs module**\n2. **Bean::merge()** - Three-way merge: base, left (ours), right (theirs)\n3. **merge_scalar_field()** - For title, priority, status, assignee, description\n4. **merge_append_field()** - For notes (always append both with timestamps)\n5. **merge_collection_field()** - For labels, dependencies (set union for adds, conflict on divergent removes)\n\n## Files\n- src/merge.rs (create - new module)\n- src/lib.rs (modify - add `pub mod merge;`)\n\n## Context\n\n### Merge rules from design doc\n```\nFor each field:\n- If base == left: take right (only right changed)\n- If base == right: take left (only left changed)  \n- If left == right: take left (both same)\n- If base != left && base != right && left != right: CONFLICT\n```\n\n### Implementation pattern\n```rust\n// src/merge.rs\nuse crate::bean::{Bean, FieldConflict, ConflictVersion, ConflictResolution};\nuse anyhow::Result;\nuse chrono::Utc;\n\n/// Result of a merge operation\npub struct MergeResult {\n    /// Fields that had conflicts (could not auto-merge)\n    pub conflicts: Vec<String>,\n    /// Fields that were auto-merged successfully  \n    pub merged: Vec<String>,\n}\n\nimpl Bean {\n    /// Three-way merge: self is left (ours), base is original, right is theirs\n    /// Returns list of conflicting field names (empty = success)\n    pub fn merge(&mut self, base: &Bean, right: &Bean) -> Result<MergeResult> {\n        let mut result = MergeResult { conflicts: vec![], merged: vec![] };\n        \n        // Scalar fields\n        self.merge_scalar(\"title\", &base.title, &self.title.clone(), &right.title, &mut result)?;\n        self.merge_scalar(\"priority\", &base.priority, &self.priority, &right.priority, &mut result)?;\n        self.merge_scalar(\"status\", &base.status, &self.status, &right.status, &mut result)?;\n        // ... etc for other scalar fields\n        \n        // Append fields (notes)\n        self.merge_append(\"notes\", &base.notes, &self.notes.clone(), &right.notes, &mut result)?;\n        \n        // Collection fields\n        self.merge_collection(\"labels\", &base.labels, &self.labels.clone(), &right.labels, &mut result)?;\n        self.merge_collection(\"dependencies\", &base.dependencies, &self.dependencies.clone(), &right.dependencies, &mut result)?;\n        \n        Ok(result)\n    }\n    \n    fn merge_scalar<T: PartialEq + Clone>(\n        &mut self,\n        field: &str,\n        base: &T,\n        left: &T,\n        right: &T,\n        result: &mut MergeResult,\n    ) -> Result<()> {\n        // ... implement 3-way merge logic\n    }\n}\n```\n\n### Conflict recording\nWhen a conflict is detected, add to `self.conflicts`:\n```rust\nself.conflicts.push(FieldConflict {\n    field: field.to_string(),\n    versions: vec![\n        ConflictVersion {\n            value: serde_json::to_string(left)?,\n            agent: \"left\".to_string(),\n            timestamp: Utc::now(),\n        },\n        ConflictVersion {\n            value: serde_json::to_string(right)?,\n            agent: \"right\".to_string(),\n            timestamp: Utc::now(),\n        },\n    ],\n    resolution: ConflictResolution::Pending,\n});\n```\n\n## Acceptance\n- [ ] src/merge.rs module exists and is exported\n- [ ] Bean::merge() implements 3-way merge for all fields\n- [ ] Non-overlapping changes auto-merge correctly\n- [ ] Overlapping changes create FieldConflict records\n- [ ] Notes field always appends (no conflicts)\n- [ ] Collection fields use set-union for adds\n- [ ] Tests cover all merge scenarios\n- [ ] cargo test merge::tests passes\n\n## Produces\n- merge_module\n- Bean::merge\n- MergeResult\n\n\n## Requires\n- FieldConflict\n- ConflictVersion\n- ConflictResolution\n"
closed_at: 2026-02-03T07:27:31.995536Z
close_reason: 'Implemented 3-way merge logic in src/merge.rs: MergeResult struct, Bean::merge() with scalar/optional/collection field merging, notes append (no conflicts), conflict detection and recording. Added FieldConflict, ConflictVersion, ConflictResolution types and conflicts field to bean.rs as prerequisites. All 19 merge tests pass.'
parent: '13'
verify: cargo test merge::tests
claimed_at: 2026-02-03T07:22:47.998484Z
is_archived: true

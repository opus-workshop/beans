id: '13.1'
title: Add conflict types and hash tracking to Bean
slug: add-conflict-types-and-hash-tracking-to-bean
status: in_progress
priority: 1
created_at: 2026-02-03T07:22:01.391013Z
updated_at: 2026-02-03T07:36:53.020044Z
description: "## What to implement\n\nAdd the foundational types and methods for conflict detection:\n\n1. **FieldConflict struct** - Records a conflict on a single field\n2. **ConflictVersion struct** - A competing value with metadata (agent, timestamp)\n3. **ConflictResolution enum** - Pending/Resolved/Discarded states\n4. **Add `conflicts` field** to Bean struct\n5. **Bean::hash()** - Calculate SHA256 hash of canonical bean form\n6. **Bean::from_file_with_hash()** - Load bean and return its hash for optimistic locking\n\n## Files\n- src/bean.rs (modify - add types, conflicts field, hash methods)\n\n## Context\n\n### From design doc (docs/design/CONFLICT_RESOLUTION.md)\n```rust\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct FieldConflict {\n    pub field: String,\n    pub versions: Vec<ConflictVersion>,\n    pub resolution: ConflictResolution,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct ConflictVersion {\n    pub value: String,  // JSON-serialized value\n    pub agent: String,\n    pub timestamp: DateTime<Utc>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub enum ConflictResolution {\n    #[serde(rename = \"pending\")]\n    Pending,\n    #[serde(rename = \"resolved\")]\n    Resolved,\n    #[serde(rename = \"discarded\")]\n    Discarded,\n}\n```\n\n### Existing Bean struct pattern\n```rust\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Bean {\n    pub id: String,\n    pub title: String,\n    // ... existing fields ...\n    \n    // ADD:\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub conflicts: Vec<FieldConflict>,\n}\n```\n\n### Hash implementation\n```rust\nimpl Bean {\n    /// Calculate SHA256 hash of canonical form\n    pub fn hash(&self) -> String {\n        use sha2::{Sha256, Digest};\n        // Clone and clear non-content fields\n        let mut canonical = self.clone();\n        canonical.conflicts = Vec::new();  // Don't include conflicts in hash\n        \n        // Serialize to JSON (deterministic)\n        let json = serde_json::to_string(&canonical).unwrap();\n        let mut hasher = Sha256::new();\n        hasher.update(json.as_bytes());\n        format!(\"{:x}\", hasher.finalize())\n    }\n    \n    /// Load bean with version hash for optimistic locking\n    pub fn from_file_with_hash(path: impl AsRef<Path>) -> Result<(Self, String)> {\n        let bean = Self::from_file(path)?;\n        let hash = bean.hash();\n        Ok((bean, hash))\n    }\n}\n```\n\n## Acceptance\n- [ ] FieldConflict, ConflictVersion, ConflictResolution types exist and serialize/deserialize correctly\n- [ ] Bean struct has `conflicts` field that defaults to empty vec\n- [ ] `Bean::hash()` returns consistent SHA256 hash for same content\n- [ ] `Bean::from_file_with_hash()` returns bean + hash tuple\n- [ ] Existing bean tests still pass\n- [ ] cargo test bean::tests passes\n\n## Produces\n- FieldConflict\n- ConflictVersion\n- ConflictResolution\n- Bean::hash\n- Bean::from_file_with_hash\n"
parent: '13'
verify: cargo test bean::tests
claimed_at: 2026-02-03T07:36:53.020044Z
